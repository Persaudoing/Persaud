"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/birdeye.ts":
/*!******************************!*\
  !*** ./src/utils/birdeye.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTrendingTokens: function() { return /* binding */ getTrendingTokens; }\n/* harmony export */ });\nfunction getBirdeyeApiKey() {\n    const apiKey = \"your_birdeye_api_key\";\n    if (!apiKey) {\n        throw new Error(\"BIRDEYE_API_KEY is not configured\");\n    }\n    return apiKey;\n}\nasync function getTrendingTokens() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    try {\n        const response = await fetch(\"https://public-api.birdeye.so/defi/tokenlist?sort_by=v24hChangePercent&sort_type=desc&offset=0&limit=\".concat(limit), {\n            headers: {\n                \"accept\": \"application/json\",\n                \"x-chain\": \"solana\",\n                \"X-API-KEY\": getBirdeyeApiKey()\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(\"Birdeye API request failed\");\n        }\n        return data.data.tokens;\n    } catch (error) {\n        console.error(\"Error fetching Birdeye trending tokens:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9iaXJkZXllLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFzQkEsU0FBU0E7SUFDUCxNQUFNQyxTQUFTQyxzQkFBdUM7SUFDdEQsSUFBSSxDQUFDRCxRQUFRO1FBQ1gsTUFBTSxJQUFJSSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0o7QUFDVDtBQUVPLGVBQWVLO1FBQWtCQyxRQUFBQSxpRUFBZ0I7SUFDdEQsSUFBSTtRQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFDckIsd0dBQThHLE9BQU5GLFFBQ3hHO1lBQ0VHLFNBQVM7Z0JBQ1AsVUFBVTtnQkFDVixXQUFXO2dCQUNYLGFBQWFWO1lBQ2Y7UUFDRjtRQUdGLElBQUksQ0FBQ1EsU0FBU0csRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSU4sTUFBTSx1QkFBdUMsT0FBaEJHLFNBQVNJLE1BQU07UUFDeEQ7UUFFQSxNQUFNQyxPQUFPLE1BQU1MLFNBQVNNLElBQUk7UUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxPQUFPLEVBQUU7WUFDakIsTUFBTSxJQUFJVixNQUFNO1FBQ2xCO1FBRUEsT0FBT1EsS0FBS0EsSUFBSSxDQUFDRyxNQUFNO0lBQ3pCLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RCxNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2JpcmRleWUudHM/ZWJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgQmlyZGV5ZVRva2VuIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBkZWNpbWFsczogbnVtYmVyO1xuICBsb2dvVVJJOiBzdHJpbmc7XG4gIGxpcXVpZGl0eTogbnVtYmVyO1xuICB2MjRoQ2hhbmdlUGVyY2VudDogbnVtYmVyO1xuICB2MjRoVVNEOiBudW1iZXI7XG4gIG1jOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBCaXJkZXllUmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhOiB7XG4gICAgdXBkYXRlVW5peFRpbWU6IG51bWJlcjtcbiAgICB1cGRhdGVUaW1lOiBzdHJpbmc7XG4gICAgdG9rZW5zOiBCaXJkZXllVG9rZW5bXTtcbiAgICB0b3RhbDogbnVtYmVyO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRCaXJkZXllQXBpS2V5KCk6IHN0cmluZyB7XG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JJUkRFWUVfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JJUkRFWUVfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZCcpO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmVuZGluZ1Rva2VucyhsaW1pdDogbnVtYmVyID0gMTApOiBQcm9taXNlPEJpcmRleWVUb2tlbltdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL3B1YmxpYy1hcGkuYmlyZGV5ZS5zby9kZWZpL3Rva2VubGlzdD9zb3J0X2J5PXYyNGhDaGFuZ2VQZXJjZW50JnNvcnRfdHlwZT1kZXNjJm9mZnNldD0wJmxpbWl0PSR7bGltaXR9YCxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdhY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ3gtY2hhaW4nOiAnc29sYW5hJyxcbiAgICAgICAgICAnWC1BUEktS0VZJzogZ2V0QmlyZGV5ZUFwaUtleSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkgYXMgQmlyZGV5ZVJlc3BvbnNlO1xuXG4gICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlyZGV5ZSBBUEkgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5kYXRhLnRva2VucztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBCaXJkZXllIHRyZW5kaW5nIHRva2VuczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0iXSwibmFtZXMiOlsiZ2V0QmlyZGV5ZUFwaUtleSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CSVJERVlFX0FQSV9LRVkiLCJFcnJvciIsImdldFRyZW5kaW5nVG9rZW5zIiwibGltaXQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwidG9rZW5zIiwiZXJyb3IiLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/birdeye.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/helius.ts":
/*!*****************************!*\
  !*** ./src/utils/helius.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSolanaBalance: function() { return /* binding */ getSolanaBalance; },\n/* harmony export */   getTransactionDetails: function() { return /* binding */ getTransactionDetails; }\n/* harmony export */ });\n/* harmony import */ var _coingecko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coingecko */ \"(app-pages-browser)/./src/utils/coingecko.ts\");\n\nfunction getHeliusRpcUrl() {\n    const apiKey = \"a0a75c78-7525-4654-a101-a61f889a6873\";\n    if (!apiKey) {\n        throw new Error(\"HELIUS_API_KEY is not configured\");\n    }\n    return \"https://mainnet.helius-rpc.com/?api-key=\".concat(apiKey);\n}\nconst rateLimiter = {\n    lastRequest: 0,\n    minInterval: 100,\n    async throttle () {\n        const now = Date.now();\n        const timeSinceLastRequest = now - this.lastRequest;\n        if (timeSinceLastRequest < this.minInterval) {\n            await new Promise((resolve)=>setTimeout(resolve, this.minInterval - timeSinceLastRequest));\n        }\n        this.lastRequest = Date.now();\n    }\n};\nasync function getSolanaBalance(address) {\n    if (!address) {\n        throw new Error(\"Address is required\");\n    }\n    await rateLimiter.throttle();\n    try {\n        var _data_result;\n        const heliusUrl = getHeliusRpcUrl();\n        const response = await fetch(heliusUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"balance-request\",\n                method: \"getBalance\",\n                params: [\n                    address\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.error) {\n            throw new Error(\"Helius API error: \".concat(data.error.message));\n        }\n        const balanceInSOL = Number(((_data_result = data.result) === null || _data_result === void 0 ? void 0 : _data_result.value) || 0) / 1e9;\n        // Get SOL price using existing utility\n        const [priceData] = await Promise.all([\n            (0,_coingecko__WEBPACK_IMPORTED_MODULE_0__.getSolanaPrice)()\n        ]);\n        return {\n            balance: balanceInSOL,\n            balanceInUSD: balanceInSOL * priceData.price\n        };\n    } catch (error) {\n        console.error(\"Error in getSolanaBalance:\", error);\n        throw error;\n    }\n}\nasync function getTransactionDetails(signature) {\n    await rateLimiter.throttle();\n    try {\n        var _tx_meta_postTokenBalances, _tx_meta, _tx_meta_preTokenBalances, _tx_meta1, _tx_meta2, _tx_meta3, _tx_meta_postBalances, _tx_meta4, _tx_meta_preBalances, _tx_meta5, _tx_meta6, _tx_transaction_message_accountKeys, _tx_transaction_message, _tx_transaction, _tx_transaction_message_accountKeys1, _tx_transaction_message1, _tx_transaction1;\n        const heliusUrl = getHeliusRpcUrl();\n        const response = await fetch(heliusUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"tx-request\",\n                method: \"getTransaction\",\n                params: [\n                    signature,\n                    {\n                        encoding: \"jsonParsed\",\n                        maxSupportedTransactionVersion: 0\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.error) {\n            throw new Error(\"Helius API error: \".concat(data.error.message));\n        }\n        const tx = data.result;\n        if (!tx) {\n            throw new Error(\"Transaction not found\");\n        }\n        // Parse token transfers with better detection\n        let tokenTransfer;\n        if (((_tx_meta = tx.meta) === null || _tx_meta === void 0 ? void 0 : (_tx_meta_postTokenBalances = _tx_meta.postTokenBalances) === null || _tx_meta_postTokenBalances === void 0 ? void 0 : _tx_meta_postTokenBalances.length) > 0 || ((_tx_meta1 = tx.meta) === null || _tx_meta1 === void 0 ? void 0 : (_tx_meta_preTokenBalances = _tx_meta1.preTokenBalances) === null || _tx_meta_preTokenBalances === void 0 ? void 0 : _tx_meta_preTokenBalances.length) > 0) {\n            const postBalances = tx.meta.postTokenBalances || [];\n            const preBalances = tx.meta.preTokenBalances || [];\n            for(let i = 0; i < Math.max(postBalances.length, preBalances.length); i++){\n                const postBalance = postBalances[i];\n                const preBalance = preBalances.find((pre)=>pre.accountIndex === (postBalance === null || postBalance === void 0 ? void 0 : postBalance.accountIndex));\n                if ((postBalance === null || postBalance === void 0 ? void 0 : postBalance.uiTokenAmount) && (preBalance === null || preBalance === void 0 ? void 0 : preBalance.uiTokenAmount)) {\n                    const amount = Math.abs((postBalance.uiTokenAmount.uiAmount || 0) - (preBalance.uiTokenAmount.uiAmount || 0));\n                    if (amount > 0) {\n                        var _tx_transaction_message_accountKeys2, _tx_transaction_message2, _tx_transaction2;\n                        const tokenAddress = (_tx_transaction2 = tx.transaction) === null || _tx_transaction2 === void 0 ? void 0 : (_tx_transaction_message2 = _tx_transaction2.message) === null || _tx_transaction_message2 === void 0 ? void 0 : (_tx_transaction_message_accountKeys2 = _tx_transaction_message2.accountKeys) === null || _tx_transaction_message_accountKeys2 === void 0 ? void 0 : _tx_transaction_message_accountKeys2[postBalance.accountIndex];\n                        tokenTransfer = {\n                            amount,\n                            symbol: postBalance.uiTokenAmount.uiTokenSymbol || \"\",\n                            tokenAddress\n                        };\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            type: ((_tx_meta2 = tx.meta) === null || _tx_meta2 === void 0 ? void 0 : _tx_meta2.type) || \"Unknown\",\n            timestamp: new Date(tx.blockTime * 1000).toLocaleString(),\n            status: ((_tx_meta3 = tx.meta) === null || _tx_meta3 === void 0 ? void 0 : _tx_meta3.err) ? \"Failed\" : \"Success\",\n            amount: (((_tx_meta4 = tx.meta) === null || _tx_meta4 === void 0 ? void 0 : (_tx_meta_postBalances = _tx_meta4.postBalances) === null || _tx_meta_postBalances === void 0 ? void 0 : _tx_meta_postBalances[0]) || 0) - (((_tx_meta5 = tx.meta) === null || _tx_meta5 === void 0 ? void 0 : (_tx_meta_preBalances = _tx_meta5.preBalances) === null || _tx_meta_preBalances === void 0 ? void 0 : _tx_meta_preBalances[0]) || 0),\n            fee: ((_tx_meta6 = tx.meta) === null || _tx_meta6 === void 0 ? void 0 : _tx_meta6.fee) ? tx.meta.fee / 1e9 : undefined,\n            sender: (_tx_transaction = tx.transaction) === null || _tx_transaction === void 0 ? void 0 : (_tx_transaction_message = _tx_transaction.message) === null || _tx_transaction_message === void 0 ? void 0 : (_tx_transaction_message_accountKeys = _tx_transaction_message.accountKeys) === null || _tx_transaction_message_accountKeys === void 0 ? void 0 : _tx_transaction_message_accountKeys[0],\n            receiver: (_tx_transaction1 = tx.transaction) === null || _tx_transaction1 === void 0 ? void 0 : (_tx_transaction_message1 = _tx_transaction1.message) === null || _tx_transaction_message1 === void 0 ? void 0 : (_tx_transaction_message_accountKeys1 = _tx_transaction_message1.accountKeys) === null || _tx_transaction_message_accountKeys1 === void 0 ? void 0 : _tx_transaction_message_accountKeys1[1],\n            tokenTransfer\n        };\n    } catch (error) {\n        console.error(\"Error fetching transaction details:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixXQUFXLGNBQWR2Qix1Q0FBQUEsMEJBQUFBLGdCQUFnQmIsT0FBTyxjQUF2QmEsK0NBQUFBLHNDQUFBQSx3QkFBeUJ3QixXQUFXLGNBQXBDeEIsMERBQUFBLG1DQUFzQyxDQUFDLEVBQUU7WUFDakRtQyxRQUFRLEdBQUVuQyxtQkFBQUEsR0FBR3VCLFdBQVcsY0FBZHZCLHdDQUFBQSwyQkFBQUEsaUJBQWdCYixPQUFPLGNBQXZCYSxnREFBQUEsdUNBQUFBLHlCQUF5QndCLFdBQVcsY0FBcEN4QiwyREFBQUEsb0NBQXNDLENBQUMsRUFBRTtZQUNuREc7UUFDRjtJQUNGLEVBQUUsT0FBT2pCLE9BQU87UUFDZFcsUUFBUVgsS0FBSyxDQUFDLHVDQUF1Q0E7UUFDckQsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9oZWxpdXMudHM/N2ZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTb2xhbmFQcmljZSB9IGZyb20gXCIuL2NvaW5nZWNrb1wiO1xuXG5pbnRlcmZhY2UgQmFsYW5jZVJlc3BvbnNlIHtcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBiYWxhbmNlSW5VU0Q6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRGV0YWlsIHtcbiAgdHlwZTogc3RyaW5nO1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGFtb3VudD86IG51bWJlcjtcbiAgc2VuZGVyPzogc3RyaW5nO1xuICByZWNlaXZlcj86IHN0cmluZztcbiAgZmVlPzogbnVtYmVyO1xuICB0b2tlblRyYW5zZmVyPzoge1xuICAgIGFtb3VudDogbnVtYmVyO1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHRva2VuQWRkcmVzcz86IHN0cmluZztcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFRva2VuQW1vdW50IHtcbiAgdWlBbW91bnQ6IG51bWJlciB8IG51bGw7XG4gIHVpVG9rZW5TeW1ib2w6IHN0cmluZyB8IG51bGw7XG59XG5cbmludGVyZmFjZSBUb2tlbkJhbGFuY2Uge1xuICBhY2NvdW50SW5kZXg6IG51bWJlcjtcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnQ7XG59XG5cbmZ1bmN0aW9uIGdldEhlbGl1c1JwY1VybCgpOiBzdHJpbmcge1xuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUxJVVNfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hFTElVU19BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gIH1cbiAgcmV0dXJuIGBodHRwczovL21haW5uZXQuaGVsaXVzLXJwYy5jb20vP2FwaS1rZXk9JHthcGlLZXl9YDtcbn1cblxuY29uc3QgcmF0ZUxpbWl0ZXIgPSB7XG4gIGxhc3RSZXF1ZXN0OiAwLFxuICBtaW5JbnRlcnZhbDogMTAwLFxuICBcbiAgYXN5bmMgdGhyb3R0bGUoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0UmVxdWVzdCA9IG5vdyAtIHRoaXMubGFzdFJlcXVlc3Q7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5taW5JbnRlcnZhbCkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMubWluSW50ZXJ2YWwgLSB0aW1lU2luY2VMYXN0UmVxdWVzdCkpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcbiAgfVxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNvbGFuYUJhbGFuY2UoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCYWxhbmNlUmVzcG9uc2U+IHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBhd2FpdCByYXRlTGltaXRlci50aHJvdHRsZSgpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgaGVsaXVzVXJsID0gZ2V0SGVsaXVzUnBjVXJsKCk7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChoZWxpdXNVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiAnYmFsYW5jZS1yZXF1ZXN0JyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0QmFsYW5jZScsXG4gICAgICAgIHBhcmFtczogW2FkZHJlc3NdLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIZWxpdXMgQVBJIGVycm9yOiAke2RhdGEuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWxhbmNlSW5TT0wgPSBOdW1iZXIoZGF0YS5yZXN1bHQ/LnZhbHVlIHx8IDApIC8gMWU5O1xuICAgIFxuICAgIC8vIEdldCBTT0wgcHJpY2UgdXNpbmcgZXhpc3RpbmcgdXRpbGl0eVxuICAgIGNvbnN0IFtwcmljZURhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgZ2V0U29sYW5hUHJpY2UoKVxuICAgIF0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBiYWxhbmNlOiBiYWxhbmNlSW5TT0wsXG4gICAgICBiYWxhbmNlSW5VU0Q6IGJhbGFuY2VJblNPTCAqIHByaWNlRGF0YS5wcmljZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0U29sYW5hQmFsYW5jZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uRGV0YWlscyhzaWduYXR1cmU6IHN0cmluZyk6IFByb21pc2U8VHJhbnNhY3Rpb25EZXRhaWw+IHtcbiAgYXdhaXQgcmF0ZUxpbWl0ZXIudGhyb3R0bGUoKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGhlbGl1c1VybCA9IGdldEhlbGl1c1JwY1VybCgpO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaGVsaXVzVXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ3R4LXJlcXVlc3QnLFxuICAgICAgICBtZXRob2Q6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogW1xuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICB7IGVuY29kaW5nOiAnanNvblBhcnNlZCcsIG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbjogMCB9XG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhlbGl1cyBBUEkgZXJyb3I6ICR7ZGF0YS5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gZGF0YS5yZXN1bHQ7XG4gICAgaWYgKCF0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0b2tlbiB0cmFuc2ZlcnMgd2l0aCBiZXR0ZXIgZGV0ZWN0aW9uXG4gICAgbGV0IHRva2VuVHJhbnNmZXI7XG4gICAgaWYgKHR4Lm1ldGE/LnBvc3RUb2tlbkJhbGFuY2VzPy5sZW5ndGggPiAwIHx8IHR4Lm1ldGE/LnByZVRva2VuQmFsYW5jZXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBvc3RCYWxhbmNlcyA9IHR4Lm1ldGEucG9zdFRva2VuQmFsYW5jZXMgYXMgVG9rZW5CYWxhbmNlW10gfHwgW107XG4gICAgICBjb25zdCBwcmVCYWxhbmNlcyA9IHR4Lm1ldGEucHJlVG9rZW5CYWxhbmNlcyBhcyBUb2tlbkJhbGFuY2VbXSB8fCBbXTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwb3N0QmFsYW5jZXMubGVuZ3RoLCBwcmVCYWxhbmNlcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9zdEJhbGFuY2UgPSBwb3N0QmFsYW5jZXNbaV07XG4gICAgICAgIGNvbnN0IHByZUJhbGFuY2UgPSBwcmVCYWxhbmNlcy5maW5kKChwcmU6IFRva2VuQmFsYW5jZSkgPT4gcHJlLmFjY291bnRJbmRleCA9PT0gcG9zdEJhbGFuY2U/LmFjY291bnRJbmRleCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zdEJhbGFuY2U/LnVpVG9rZW5BbW91bnQgJiYgcHJlQmFsYW5jZT8udWlUb2tlbkFtb3VudCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IE1hdGguYWJzKFxuICAgICAgICAgICAgKHBvc3RCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlBbW91bnQgfHwgMCkgLSBcbiAgICAgICAgICAgIChwcmVCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlBbW91bnQgfHwgMClcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhbW91bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkFkZHJlc3MgPSB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/Lltwb3N0QmFsYW5jZS5hY2NvdW50SW5kZXhdO1xuICAgICAgICAgICAgdG9rZW5UcmFuc2ZlciA9IHtcbiAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICBzeW1ib2w6IHBvc3RCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlUb2tlblN5bWJvbCB8fCAnJyxcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR4Lm1ldGE/LnR5cGUgfHwgJ1Vua25vd24nLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0eC5ibG9ja1RpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgc3RhdHVzOiB0eC5tZXRhPy5lcnIgPyAnRmFpbGVkJyA6ICdTdWNjZXNzJyxcbiAgICAgIGFtb3VudDogKHR4Lm1ldGE/LnBvc3RCYWxhbmNlcz8uWzBdIHx8IDApIC0gKHR4Lm1ldGE/LnByZUJhbGFuY2VzPy5bMF0gfHwgMCksXG4gICAgICBmZWU6IHR4Lm1ldGE/LmZlZSA/IHR4Lm1ldGEuZmVlIC8gMWU5IDogdW5kZWZpbmVkLFxuICAgICAgc2VuZGVyOiB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/LlswXSxcbiAgICAgIHJlY2VpdmVyOiB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/LlsxXSxcbiAgICAgIHRva2VuVHJhbnNmZXJcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRyYW5zYWN0aW9uIGRldGFpbHM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG4iXSwibmFtZXMiOlsiZ2V0U29sYW5hUHJpY2UiLCJnZXRIZWxpdXNScGNVcmwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSEVMSVVTX0FQSV9LRVkiLCJFcnJvciIsInJhdGVMaW1pdGVyIiwibGFzdFJlcXVlc3QiLCJtaW5JbnRlcnZhbCIsInRocm90dGxlIiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RSZXF1ZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0U29sYW5hQmFsYW5jZSIsImFkZHJlc3MiLCJkYXRhIiwiaGVsaXVzVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb25ycGMiLCJpZCIsInBhcmFtcyIsIm9rIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwibWVzc2FnZSIsImJhbGFuY2VJblNPTCIsIk51bWJlciIsInJlc3VsdCIsInZhbHVlIiwicHJpY2VEYXRhIiwiYWxsIiwiYmFsYW5jZSIsImJhbGFuY2VJblVTRCIsInByaWNlIiwiY29uc29sZSIsImdldFRyYW5zYWN0aW9uRGV0YWlscyIsInNpZ25hdHVyZSIsInR4IiwiZW5jb2RpbmciLCJtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb24iLCJ0b2tlblRyYW5zZmVyIiwibWV0YSIsInBvc3RUb2tlbkJhbGFuY2VzIiwibGVuZ3RoIiwicHJlVG9rZW5CYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZUJhbGFuY2VzIiwiaSIsIk1hdGgiLCJtYXgiLCJwb3N0QmFsYW5jZSIsInByZUJhbGFuY2UiLCJmaW5kIiwicHJlIiwiYWNjb3VudEluZGV4IiwidWlUb2tlbkFtb3VudCIsImFtb3VudCIsImFicyIsInVpQW1vdW50IiwidG9rZW5BZGRyZXNzIiwidHJhbnNhY3Rpb24iLCJhY2NvdW50S2V5cyIsInN5bWJvbCIsInVpVG9rZW5TeW1ib2wiLCJ0eXBlIiwidGltZXN0YW1wIiwiYmxvY2tUaW1lIiwidG9Mb2NhbGVTdHJpbmciLCJlcnIiLCJmZWUiLCJ1bmRlZmluZWQiLCJzZW5kZXIiLCJyZWNlaXZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/helius.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/wallet.ts":
/*!*****************************!*\
  !*** ./src/utils/wallet.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentWallet: function() { return /* binding */ AgentWallet; },\n/* harmony export */   agentWallet: function() { return /* binding */ agentWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../../node_modules/process/browser.js\");\n\nclass AgentWallet {\n    async getActiveConnection() {\n        if (!this.isUsingFallback) {\n            try {\n                if (!this.primaryConnection) {\n                    throw new Error(\"Primary connection not initialized\");\n                }\n                await this.primaryConnection.getSlot();\n                return this.primaryConnection;\n            } catch (error) {\n                console.warn(\"Primary RPC failed, switching to fallback:\", error);\n                this.isUsingFallback = true;\n            }\n        }\n        if (!this.fallbackConnection) {\n            throw new Error(\"Fallback connection not initialized\");\n        }\n        try {\n            await this.fallbackConnection.getSlot();\n            return this.fallbackConnection;\n        } catch (error) {\n            console.error(\"Both RPC connections failed:\", error);\n            throw new Error(\"No available RPC connection\");\n        }\n    }\n    async getBalance() {\n        const maxRetries = 3;\n        let retryCount = 0;\n        while(retryCount < maxRetries){\n            try {\n                const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet\"), {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Failed to get wallet balance\");\n                }\n                return await response.json();\n            } catch (error) {\n                retryCount++;\n                if (retryCount === maxRetries) {\n                    console.error(\"Error getting wallet balance after retries:\", error);\n                    throw error;\n                }\n                // Wait before retrying\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            }\n        }\n        throw new Error(\"Failed to get wallet balance after retries\");\n    }\n    async sendSOL(recipient, amount) {\n        try {\n            const connection = await this.getActiveConnection();\n            const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet/send\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    recipient,\n                    amount,\n                    rpcUrl: this.isUsingFallback ? \"helius\" : \"quicknode\"\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to send transaction\");\n            }\n            return response.json();\n        } catch (error) {\n            console.error(\"Error sending SOL:\", error);\n            throw error;\n        }\n    }\n    async signAndSendTransaction(transaction) {\n        try {\n            const connection = await this.getActiveConnection();\n            const serializedTransaction = Buffer.from(transaction.serialize()).toString(\"base64\");\n            const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet/sign\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    transaction: serializedTransaction,\n                    rpcUrl: this.isUsingFallback ? \"helius\" : \"quicknode\"\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to sign and send transaction\");\n            }\n            const result = await response.json();\n            return result.signature;\n        } catch (error) {\n            console.error(\"Error signing transaction:\", error);\n            throw error;\n        }\n    }\n    async getAddress() {\n        const walletInfo = await this.getBalance();\n        return walletInfo.address;\n    }\n    constructor(){\n        this.primaryConnection = null;\n        this.fallbackConnection = null;\n        this.isUsingFallback = false;\n        const quickNodeUrl = \"your_quicknode_rpc_url\";\n        const heliusApiKey = \"a0a75c78-7525-4654-a101-a61f889a6873\";\n        if (!quickNodeUrl && !heliusApiKey) {\n            throw new Error(\"Missing RPC configuration\");\n        }\n        // Initialize QuickNode as primary if available\n        if (quickNodeUrl) {\n            this.primaryConnection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(quickNodeUrl, \"confirmed\");\n        }\n        // Initialize Helius as fallback\n        if (heliusApiKey) {\n            this.fallbackConnection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(\"https://mainnet.helius-rpc.com/?api-key=\".concat(heliusApiKey), \"confirmed\");\n        }\n        // If QuickNode isn't available, use Helius as primary\n        if (!quickNodeUrl && heliusApiKey) {\n            this.primaryConnection = this.fallbackConnection;\n        }\n        // Use appropriate base URL depending on environment\n        this.baseUrl = process.env.BOT_API_BASE_URL || process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:3000\";\n    }\n}\n// Export a singleton instance\nconst agentWallet = new AgentWallet();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDTSxrQkFBa0I7UUFDbEQ7UUFFQSxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDTSxPQUFPLEdBQUcrQixPQUFPQSxDQUFDQyxHQUFHLENBQUNJLGdCQUFnQixJQUFJTCxPQUFPQSxDQUFDQyxHQUFHLENBQUNLLHdCQUF3QixJQUFJO0lBQ3pGO0FBb0hGO0FBRUEsOEJBQThCO0FBQ3ZCLE1BQU1DLGNBQWMsSUFBSXJELGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3dhbGxldC50cz8yOTAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24sIFZlcnNpb25lZFRyYW5zYWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW50ZXJmYWNlIFdhbGxldEJhbGFuY2Uge1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUmVzdWx0IHtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2Vycm9yJztcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQWdlbnRXYWxsZXQge1xuICBwcml2YXRlIHByaW1hcnlDb25uZWN0aW9uOiBDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZmFsbGJhY2tDb25uZWN0aW9uOiBDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNVc2luZ0ZhbGxiYWNrOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYmFzZVVybDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHF1aWNrTm9kZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1FVSUNLTk9ERV9SUENfVVJMO1xuICAgIGNvbnN0IGhlbGl1c0FwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0hFTElVU19BUElfS0VZO1xuXG4gICAgaWYgKCFxdWlja05vZGVVcmwgJiYgIWhlbGl1c0FwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFJQQyBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBRdWlja05vZGUgYXMgcHJpbWFyeSBpZiBhdmFpbGFibGVcbiAgICBpZiAocXVpY2tOb2RlVXJsKSB7XG4gICAgICB0aGlzLnByaW1hcnlDb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24ocXVpY2tOb2RlVXJsLCAnY29uZmlybWVkJyk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBIZWxpdXMgYXMgZmFsbGJhY2tcbiAgICBpZiAoaGVsaXVzQXBpS2V5KSB7XG4gICAgICB0aGlzLmZhbGxiYWNrQ29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFxuICAgICAgICBgaHR0cHM6Ly9tYWlubmV0LmhlbGl1cy1ycGMuY29tLz9hcGkta2V5PSR7aGVsaXVzQXBpS2V5fWAsXG4gICAgICAgICdjb25maXJtZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIFF1aWNrTm9kZSBpc24ndCBhdmFpbGFibGUsIHVzZSBIZWxpdXMgYXMgcHJpbWFyeVxuICAgIGlmICghcXVpY2tOb2RlVXJsICYmIGhlbGl1c0FwaUtleSkge1xuICAgICAgdGhpcy5wcmltYXJ5Q29ubmVjdGlvbiA9IHRoaXMuZmFsbGJhY2tDb25uZWN0aW9uO1xuICAgIH1cblxuICAgIC8vIFVzZSBhcHByb3ByaWF0ZSBiYXNlIFVSTCBkZXBlbmRpbmcgb24gZW52aXJvbm1lbnRcbiAgICB0aGlzLmJhc2VVcmwgPSBwcm9jZXNzLmVudi5CT1RfQVBJX0JBU0VfVVJMIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRBY3RpdmVDb25uZWN0aW9uKCk6IFByb21pc2U8Q29ubmVjdGlvbj4ge1xuICAgIGlmICghdGhpcy5pc1VzaW5nRmFsbGJhY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5wcmltYXJ5Q29ubmVjdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWFyeSBjb25uZWN0aW9uIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucHJpbWFyeUNvbm5lY3Rpb24uZ2V0U2xvdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5Q29ubmVjdGlvbjtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUHJpbWFyeSBSUEMgZmFpbGVkLCBzd2l0Y2hpbmcgdG8gZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgICB0aGlzLmlzVXNpbmdGYWxsYmFjayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZhbGxiYWNrQ29ubmVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxsYmFjayBjb25uZWN0aW9uIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5mYWxsYmFja0Nvbm5lY3Rpb24uZ2V0U2xvdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tDb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCb3RoIFJQQyBjb25uZWN0aW9ucyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdmFpbGFibGUgUlBDIGNvbm5lY3Rpb24nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRCYWxhbmNlKCk6IFByb21pc2U8eyBhZGRyZXNzOiBzdHJpbmc7IGJhbGFuY2U6IG51bWJlciB9PiB7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgIFxuICAgIHdoaWxlIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2FwaS93YWxsZXRgLCB7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgd2FsbGV0IGJhbGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIGlmIChyZXRyeUNvdW50ID09PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB3YWxsZXQgYmFsYW5jZSBhZnRlciByZXRyaWVzOicsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgd2FsbGV0IGJhbGFuY2UgYWZ0ZXIgcmV0cmllcycpO1xuICB9XG5cbiAgYXN5bmMgc2VuZFNPTChyZWNpcGllbnQ6IHN0cmluZywgYW1vdW50OiBudW1iZXIpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmdldEFjdGl2ZUNvbm5lY3Rpb24oKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9hcGkvd2FsbGV0L3NlbmRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgICByZWNpcGllbnQsIFxuICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICBycGNVcmw6IHRoaXMuaXNVc2luZ0ZhbGxiYWNrID8gJ2hlbGl1cycgOiAncXVpY2tub2RlJyBcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgU09MOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFZlcnNpb25lZFRyYW5zYWN0aW9uKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QWN0aXZlQ29ubmVjdGlvbigpO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gQnVmZmVyLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2FwaS93YWxsZXQvc2lnbmAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAgcnBjVXJsOiB0aGlzLmlzVXNpbmdGYWxsYmFjayA/ICdoZWxpdXMnIDogJ3F1aWNrbm9kZScgXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gc2lnbiBhbmQgc2VuZCB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2lnbmluZyB0cmFuc2FjdGlvbjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWRkcmVzcygpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHdhbGxldEluZm8gPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoKTtcbiAgICByZXR1cm4gd2FsbGV0SW5mby5hZGRyZXNzO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGFnZW50V2FsbGV0ID0gbmV3IEFnZW50V2FsbGV0KCk7XG4iXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIkFnZW50V2FsbGV0IiwiZ2V0QWN0aXZlQ29ubmVjdGlvbiIsImlzVXNpbmdGYWxsYmFjayIsInByaW1hcnlDb25uZWN0aW9uIiwiRXJyb3IiLCJnZXRTbG90IiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsImZhbGxiYWNrQ29ubmVjdGlvbiIsImdldEJhbGFuY2UiLCJtYXhSZXRyaWVzIiwicmV0cnlDb3VudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwianNvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNlbmRTT0wiLCJyZWNpcGllbnQiLCJhbW91bnQiLCJjb25uZWN0aW9uIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJycGNVcmwiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJCdWZmZXIiLCJmcm9tIiwic2VyaWFsaXplIiwidG9TdHJpbmciLCJlcnJvckRhdGEiLCJyZXN1bHQiLCJzaWduYXR1cmUiLCJnZXRBZGRyZXNzIiwid2FsbGV0SW5mbyIsImFkZHJlc3MiLCJjb25zdHJ1Y3RvciIsInF1aWNrTm9kZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19RVUlDS05PREVfUlBDX1VSTCIsImhlbGl1c0FwaUtleSIsIk5FWFRfUFVCTElDX0hFTElVU19BUElfS0VZIiwiQk9UX0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsImFnZW50V2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/wallet.ts\n"));

/***/ })

});