"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/birdeye.ts":
/*!******************************!*\
  !*** ./src/utils/birdeye.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTrendingTokens: function() { return /* binding */ getTrendingTokens; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../../node_modules/process/browser.js\");\nfunction getBirdeyeApiKey() {\n    const apiKey = process.env.NEXT_PUBLIC_BIRDEYE_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"BIRDEYE_API_KEY is not configured\");\n    }\n    return apiKey;\n}\nasync function getTrendingTokens() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    try {\n        const response = await fetch(\"https://public-api.birdeye.so/defi/tokenlist?sort_by=v24hChangePercent&sort_type=desc&offset=0&limit=\".concat(limit), {\n            headers: {\n                \"accept\": \"application/json\",\n                \"x-chain\": \"solana\",\n                \"X-API-KEY\": getBirdeyeApiKey()\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(\"Birdeye API request failed\");\n        }\n        return data.data.tokens;\n    } catch (error) {\n        console.error(\"Error fetching Birdeye trending tokens:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9iaXJkZXllLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBc0JBLFNBQVNBO0lBQ1AsTUFBTUMsU0FBU0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQywyQkFBMkI7SUFDdEQsSUFBSSxDQUFDSCxRQUFRO1FBQ1gsTUFBTSxJQUFJSSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0o7QUFDVDtBQUVPLGVBQWVLO1FBQWtCQyxRQUFBQSxpRUFBZ0I7SUFDdEQsSUFBSTtRQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFDckIsd0dBQThHLE9BQU5GLFFBQ3hHO1lBQ0VHLFNBQVM7Z0JBQ1AsVUFBVTtnQkFDVixXQUFXO2dCQUNYLGFBQWFWO1lBQ2Y7UUFDRjtRQUdGLElBQUksQ0FBQ1EsU0FBU0csRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSU4sTUFBTSx1QkFBdUMsT0FBaEJHLFNBQVNJLE1BQU07UUFDeEQ7UUFFQSxNQUFNQyxPQUFPLE1BQU1MLFNBQVNNLElBQUk7UUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxPQUFPLEVBQUU7WUFDakIsTUFBTSxJQUFJVixNQUFNO1FBQ2xCO1FBRUEsT0FBT1EsS0FBS0EsSUFBSSxDQUFDRyxNQUFNO0lBQ3pCLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RCxNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2JpcmRleWUudHM/ZWJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgQmlyZGV5ZVRva2VuIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBkZWNpbWFsczogbnVtYmVyO1xuICBsb2dvVVJJOiBzdHJpbmc7XG4gIGxpcXVpZGl0eTogbnVtYmVyO1xuICB2MjRoQ2hhbmdlUGVyY2VudDogbnVtYmVyO1xuICB2MjRoVVNEOiBudW1iZXI7XG4gIG1jOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBCaXJkZXllUmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhOiB7XG4gICAgdXBkYXRlVW5peFRpbWU6IG51bWJlcjtcbiAgICB1cGRhdGVUaW1lOiBzdHJpbmc7XG4gICAgdG9rZW5zOiBCaXJkZXllVG9rZW5bXTtcbiAgICB0b3RhbDogbnVtYmVyO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRCaXJkZXllQXBpS2V5KCk6IHN0cmluZyB7XG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JJUkRFWUVfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JJUkRFWUVfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZCcpO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmVuZGluZ1Rva2VucyhsaW1pdDogbnVtYmVyID0gMTApOiBQcm9taXNlPEJpcmRleWVUb2tlbltdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL3B1YmxpYy1hcGkuYmlyZGV5ZS5zby9kZWZpL3Rva2VubGlzdD9zb3J0X2J5PXYyNGhDaGFuZ2VQZXJjZW50JnNvcnRfdHlwZT1kZXNjJm9mZnNldD0wJmxpbWl0PSR7bGltaXR9YCxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdhY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ3gtY2hhaW4nOiAnc29sYW5hJyxcbiAgICAgICAgICAnWC1BUEktS0VZJzogZ2V0QmlyZGV5ZUFwaUtleSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkgYXMgQmlyZGV5ZVJlc3BvbnNlO1xuXG4gICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlyZGV5ZSBBUEkgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5kYXRhLnRva2VucztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBCaXJkZXllIHRyZW5kaW5nIHRva2VuczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0iXSwibmFtZXMiOlsiZ2V0QmlyZGV5ZUFwaUtleSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CSVJERVlFX0FQSV9LRVkiLCJFcnJvciIsImdldFRyZW5kaW5nVG9rZW5zIiwibGltaXQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwidG9rZW5zIiwiZXJyb3IiLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/birdeye.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/helius.ts":
/*!*****************************!*\
  !*** ./src/utils/helius.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSolanaBalance: function() { return /* binding */ getSolanaBalance; },\n/* harmony export */   getTransactionDetails: function() { return /* binding */ getTransactionDetails; }\n/* harmony export */ });\n/* harmony import */ var _coingecko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coingecko */ \"(app-pages-browser)/./src/utils/coingecko.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../../node_modules/process/browser.js\");\n\nfunction getHeliusRpcUrl() {\n    const apiKey = process.env.NEXT_PUBLIC_HELIUS_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"HELIUS_API_KEY is not configured\");\n    }\n    return \"https://mainnet.helius-rpc.com/?api-key=\".concat(apiKey);\n}\nconst rateLimiter = {\n    lastRequest: 0,\n    minInterval: 100,\n    async throttle () {\n        const now = Date.now();\n        const timeSinceLastRequest = now - this.lastRequest;\n        if (timeSinceLastRequest < this.minInterval) {\n            await new Promise((resolve)=>setTimeout(resolve, this.minInterval - timeSinceLastRequest));\n        }\n        this.lastRequest = Date.now();\n    }\n};\nasync function getSolanaBalance(address) {\n    if (!address) {\n        throw new Error(\"Address is required\");\n    }\n    await rateLimiter.throttle();\n    try {\n        var _data_result;\n        const heliusUrl = getHeliusRpcUrl();\n        const response = await fetch(heliusUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"balance-request\",\n                method: \"getBalance\",\n                params: [\n                    address\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.error) {\n            throw new Error(\"Helius API error: \".concat(data.error.message));\n        }\n        const balanceInSOL = Number(((_data_result = data.result) === null || _data_result === void 0 ? void 0 : _data_result.value) || 0) / 1e9;\n        // Get SOL price using existing utility\n        const [priceData] = await Promise.all([\n            (0,_coingecko__WEBPACK_IMPORTED_MODULE_0__.getSolanaPrice)()\n        ]);\n        return {\n            balance: balanceInSOL,\n            balanceInUSD: balanceInSOL * priceData.price\n        };\n    } catch (error) {\n        console.error(\"Error in getSolanaBalance:\", error);\n        throw error;\n    }\n}\nasync function getTransactionDetails(signature) {\n    await rateLimiter.throttle();\n    try {\n        var _tx_meta_postTokenBalances, _tx_meta, _tx_meta_preTokenBalances, _tx_meta1, _tx_meta2, _tx_meta3, _tx_meta_postBalances, _tx_meta4, _tx_meta_preBalances, _tx_meta5, _tx_meta6, _tx_transaction_message_accountKeys, _tx_transaction_message, _tx_transaction, _tx_transaction_message_accountKeys1, _tx_transaction_message1, _tx_transaction1;\n        const heliusUrl = getHeliusRpcUrl();\n        const response = await fetch(heliusUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"tx-request\",\n                method: \"getTransaction\",\n                params: [\n                    signature,\n                    {\n                        encoding: \"jsonParsed\",\n                        maxSupportedTransactionVersion: 0\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.error) {\n            throw new Error(\"Helius API error: \".concat(data.error.message));\n        }\n        const tx = data.result;\n        if (!tx) {\n            throw new Error(\"Transaction not found\");\n        }\n        // Parse token transfers with better detection\n        let tokenTransfer;\n        if (((_tx_meta = tx.meta) === null || _tx_meta === void 0 ? void 0 : (_tx_meta_postTokenBalances = _tx_meta.postTokenBalances) === null || _tx_meta_postTokenBalances === void 0 ? void 0 : _tx_meta_postTokenBalances.length) > 0 || ((_tx_meta1 = tx.meta) === null || _tx_meta1 === void 0 ? void 0 : (_tx_meta_preTokenBalances = _tx_meta1.preTokenBalances) === null || _tx_meta_preTokenBalances === void 0 ? void 0 : _tx_meta_preTokenBalances.length) > 0) {\n            const postBalances = tx.meta.postTokenBalances || [];\n            const preBalances = tx.meta.preTokenBalances || [];\n            for(let i = 0; i < Math.max(postBalances.length, preBalances.length); i++){\n                const postBalance = postBalances[i];\n                const preBalance = preBalances.find((pre)=>pre.accountIndex === (postBalance === null || postBalance === void 0 ? void 0 : postBalance.accountIndex));\n                if ((postBalance === null || postBalance === void 0 ? void 0 : postBalance.uiTokenAmount) && (preBalance === null || preBalance === void 0 ? void 0 : preBalance.uiTokenAmount)) {\n                    const amount = Math.abs((postBalance.uiTokenAmount.uiAmount || 0) - (preBalance.uiTokenAmount.uiAmount || 0));\n                    if (amount > 0) {\n                        var _tx_transaction_message_accountKeys2, _tx_transaction_message2, _tx_transaction2;\n                        const tokenAddress = (_tx_transaction2 = tx.transaction) === null || _tx_transaction2 === void 0 ? void 0 : (_tx_transaction_message2 = _tx_transaction2.message) === null || _tx_transaction_message2 === void 0 ? void 0 : (_tx_transaction_message_accountKeys2 = _tx_transaction_message2.accountKeys) === null || _tx_transaction_message_accountKeys2 === void 0 ? void 0 : _tx_transaction_message_accountKeys2[postBalance.accountIndex];\n                        tokenTransfer = {\n                            amount,\n                            symbol: postBalance.uiTokenAmount.uiTokenSymbol || \"\",\n                            tokenAddress\n                        };\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            type: ((_tx_meta2 = tx.meta) === null || _tx_meta2 === void 0 ? void 0 : _tx_meta2.type) || \"Unknown\",\n            timestamp: new Date(tx.blockTime * 1000).toLocaleString(),\n            status: ((_tx_meta3 = tx.meta) === null || _tx_meta3 === void 0 ? void 0 : _tx_meta3.err) ? \"Failed\" : \"Success\",\n            amount: (((_tx_meta4 = tx.meta) === null || _tx_meta4 === void 0 ? void 0 : (_tx_meta_postBalances = _tx_meta4.postBalances) === null || _tx_meta_postBalances === void 0 ? void 0 : _tx_meta_postBalances[0]) || 0) - (((_tx_meta5 = tx.meta) === null || _tx_meta5 === void 0 ? void 0 : (_tx_meta_preBalances = _tx_meta5.preBalances) === null || _tx_meta_preBalances === void 0 ? void 0 : _tx_meta_preBalances[0]) || 0),\n            fee: ((_tx_meta6 = tx.meta) === null || _tx_meta6 === void 0 ? void 0 : _tx_meta6.fee) ? tx.meta.fee / 1e9 : undefined,\n            sender: (_tx_transaction = tx.transaction) === null || _tx_transaction === void 0 ? void 0 : (_tx_transaction_message = _tx_transaction.message) === null || _tx_transaction_message === void 0 ? void 0 : (_tx_transaction_message_accountKeys = _tx_transaction_message.accountKeys) === null || _tx_transaction_message_accountKeys === void 0 ? void 0 : _tx_transaction_message_accountKeys[0],\n            receiver: (_tx_transaction1 = tx.transaction) === null || _tx_transaction1 === void 0 ? void 0 : (_tx_transaction_message1 = _tx_transaction1.message) === null || _tx_transaction_message1 === void 0 ? void 0 : (_tx_transaction_message_accountKeys1 = _tx_transaction_message1.accountKeys) === null || _tx_transaction_message_accountKeys1 === void 0 ? void 0 : _tx_transaction_message_accountKeys1[1],\n            tokenTransfer\n        };\n    } catch (error) {\n        console.error(\"Error fetching transaction details:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTSxHQUFFbEMsa0JBQUFBLEdBQUd1QixXQUFXLGNBQWR2Qix1Q0FBQUEsMEJBQUFBLGdCQUFnQmIsT0FBTyxjQUF2QmEsK0NBQUFBLHNDQUFBQSx3QkFBeUJ3QixXQUFXLGNBQXBDeEIsMERBQUFBLG1DQUFzQyxDQUFDLEVBQUU7WUFDakRtQyxRQUFRLEdBQUVuQyxtQkFBQUEsR0FBR3VCLFdBQVcsY0FBZHZCLHdDQUFBQSwyQkFBQUEsaUJBQWdCYixPQUFPLGNBQXZCYSxnREFBQUEsdUNBQUFBLHlCQUF5QndCLFdBQVcsY0FBcEN4QiwyREFBQUEsb0NBQXNDLENBQUMsRUFBRTtZQUNuREc7UUFDRjtJQUNGLEVBQUUsT0FBT2pCLE9BQU87UUFDZFcsUUFBUVgsS0FBSyxDQUFDLHVDQUF1Q0E7UUFDckQsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9oZWxpdXMudHM/N2ZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTb2xhbmFQcmljZSB9IGZyb20gXCIuL2NvaW5nZWNrb1wiO1xuXG5pbnRlcmZhY2UgQmFsYW5jZVJlc3BvbnNlIHtcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBiYWxhbmNlSW5VU0Q6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRGV0YWlsIHtcbiAgdHlwZTogc3RyaW5nO1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGFtb3VudD86IG51bWJlcjtcbiAgc2VuZGVyPzogc3RyaW5nO1xuICByZWNlaXZlcj86IHN0cmluZztcbiAgZmVlPzogbnVtYmVyO1xuICB0b2tlblRyYW5zZmVyPzoge1xuICAgIGFtb3VudDogbnVtYmVyO1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHRva2VuQWRkcmVzcz86IHN0cmluZztcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFRva2VuQW1vdW50IHtcbiAgdWlBbW91bnQ6IG51bWJlciB8IG51bGw7XG4gIHVpVG9rZW5TeW1ib2w6IHN0cmluZyB8IG51bGw7XG59XG5cbmludGVyZmFjZSBUb2tlbkJhbGFuY2Uge1xuICBhY2NvdW50SW5kZXg6IG51bWJlcjtcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnQ7XG59XG5cbmZ1bmN0aW9uIGdldEhlbGl1c1JwY1VybCgpOiBzdHJpbmcge1xuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUxJVVNfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hFTElVU19BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gIH1cbiAgcmV0dXJuIGBodHRwczovL21haW5uZXQuaGVsaXVzLXJwYy5jb20vP2FwaS1rZXk9JHthcGlLZXl9YDtcbn1cblxuY29uc3QgcmF0ZUxpbWl0ZXIgPSB7XG4gIGxhc3RSZXF1ZXN0OiAwLFxuICBtaW5JbnRlcnZhbDogMTAwLFxuICBcbiAgYXN5bmMgdGhyb3R0bGUoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0UmVxdWVzdCA9IG5vdyAtIHRoaXMubGFzdFJlcXVlc3Q7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5taW5JbnRlcnZhbCkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMubWluSW50ZXJ2YWwgLSB0aW1lU2luY2VMYXN0UmVxdWVzdCkpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcbiAgfVxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNvbGFuYUJhbGFuY2UoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCYWxhbmNlUmVzcG9uc2U+IHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBhd2FpdCByYXRlTGltaXRlci50aHJvdHRsZSgpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgaGVsaXVzVXJsID0gZ2V0SGVsaXVzUnBjVXJsKCk7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChoZWxpdXNVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiAnYmFsYW5jZS1yZXF1ZXN0JyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0QmFsYW5jZScsXG4gICAgICAgIHBhcmFtczogW2FkZHJlc3NdLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIZWxpdXMgQVBJIGVycm9yOiAke2RhdGEuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWxhbmNlSW5TT0wgPSBOdW1iZXIoZGF0YS5yZXN1bHQ/LnZhbHVlIHx8IDApIC8gMWU5O1xuICAgIFxuICAgIC8vIEdldCBTT0wgcHJpY2UgdXNpbmcgZXhpc3RpbmcgdXRpbGl0eVxuICAgIGNvbnN0IFtwcmljZURhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgZ2V0U29sYW5hUHJpY2UoKVxuICAgIF0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBiYWxhbmNlOiBiYWxhbmNlSW5TT0wsXG4gICAgICBiYWxhbmNlSW5VU0Q6IGJhbGFuY2VJblNPTCAqIHByaWNlRGF0YS5wcmljZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0U29sYW5hQmFsYW5jZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uRGV0YWlscyhzaWduYXR1cmU6IHN0cmluZyk6IFByb21pc2U8VHJhbnNhY3Rpb25EZXRhaWw+IHtcbiAgYXdhaXQgcmF0ZUxpbWl0ZXIudGhyb3R0bGUoKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGhlbGl1c1VybCA9IGdldEhlbGl1c1JwY1VybCgpO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaGVsaXVzVXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ3R4LXJlcXVlc3QnLFxuICAgICAgICBtZXRob2Q6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogW1xuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICB7IGVuY29kaW5nOiAnanNvblBhcnNlZCcsIG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbjogMCB9XG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhlbGl1cyBBUEkgZXJyb3I6ICR7ZGF0YS5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gZGF0YS5yZXN1bHQ7XG4gICAgaWYgKCF0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0b2tlbiB0cmFuc2ZlcnMgd2l0aCBiZXR0ZXIgZGV0ZWN0aW9uXG4gICAgbGV0IHRva2VuVHJhbnNmZXI7XG4gICAgaWYgKHR4Lm1ldGE/LnBvc3RUb2tlbkJhbGFuY2VzPy5sZW5ndGggPiAwIHx8IHR4Lm1ldGE/LnByZVRva2VuQmFsYW5jZXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBvc3RCYWxhbmNlcyA9IHR4Lm1ldGEucG9zdFRva2VuQmFsYW5jZXMgYXMgVG9rZW5CYWxhbmNlW10gfHwgW107XG4gICAgICBjb25zdCBwcmVCYWxhbmNlcyA9IHR4Lm1ldGEucHJlVG9rZW5CYWxhbmNlcyBhcyBUb2tlbkJhbGFuY2VbXSB8fCBbXTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwb3N0QmFsYW5jZXMubGVuZ3RoLCBwcmVCYWxhbmNlcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9zdEJhbGFuY2UgPSBwb3N0QmFsYW5jZXNbaV07XG4gICAgICAgIGNvbnN0IHByZUJhbGFuY2UgPSBwcmVCYWxhbmNlcy5maW5kKChwcmU6IFRva2VuQmFsYW5jZSkgPT4gcHJlLmFjY291bnRJbmRleCA9PT0gcG9zdEJhbGFuY2U/LmFjY291bnRJbmRleCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zdEJhbGFuY2U/LnVpVG9rZW5BbW91bnQgJiYgcHJlQmFsYW5jZT8udWlUb2tlbkFtb3VudCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IE1hdGguYWJzKFxuICAgICAgICAgICAgKHBvc3RCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlBbW91bnQgfHwgMCkgLSBcbiAgICAgICAgICAgIChwcmVCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlBbW91bnQgfHwgMClcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhbW91bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkFkZHJlc3MgPSB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/Lltwb3N0QmFsYW5jZS5hY2NvdW50SW5kZXhdO1xuICAgICAgICAgICAgdG9rZW5UcmFuc2ZlciA9IHtcbiAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICBzeW1ib2w6IHBvc3RCYWxhbmNlLnVpVG9rZW5BbW91bnQudWlUb2tlblN5bWJvbCB8fCAnJyxcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR4Lm1ldGE/LnR5cGUgfHwgJ1Vua25vd24nLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0eC5ibG9ja1RpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgc3RhdHVzOiB0eC5tZXRhPy5lcnIgPyAnRmFpbGVkJyA6ICdTdWNjZXNzJyxcbiAgICAgIGFtb3VudDogKHR4Lm1ldGE/LnBvc3RCYWxhbmNlcz8uWzBdIHx8IDApIC0gKHR4Lm1ldGE/LnByZUJhbGFuY2VzPy5bMF0gfHwgMCksXG4gICAgICBmZWU6IHR4Lm1ldGE/LmZlZSA/IHR4Lm1ldGEuZmVlIC8gMWU5IDogdW5kZWZpbmVkLFxuICAgICAgc2VuZGVyOiB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/LlswXSxcbiAgICAgIHJlY2VpdmVyOiB0eC50cmFuc2FjdGlvbj8ubWVzc2FnZT8uYWNjb3VudEtleXM/LlsxXSxcbiAgICAgIHRva2VuVHJhbnNmZXJcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRyYW5zYWN0aW9uIGRldGFpbHM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG4iXSwibmFtZXMiOlsiZ2V0U29sYW5hUHJpY2UiLCJnZXRIZWxpdXNScGNVcmwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSEVMSVVTX0FQSV9LRVkiLCJFcnJvciIsInJhdGVMaW1pdGVyIiwibGFzdFJlcXVlc3QiLCJtaW5JbnRlcnZhbCIsInRocm90dGxlIiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RSZXF1ZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0U29sYW5hQmFsYW5jZSIsImFkZHJlc3MiLCJkYXRhIiwiaGVsaXVzVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb25ycGMiLCJpZCIsInBhcmFtcyIsIm9rIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwibWVzc2FnZSIsImJhbGFuY2VJblNPTCIsIk51bWJlciIsInJlc3VsdCIsInZhbHVlIiwicHJpY2VEYXRhIiwiYWxsIiwiYmFsYW5jZSIsImJhbGFuY2VJblVTRCIsInByaWNlIiwiY29uc29sZSIsImdldFRyYW5zYWN0aW9uRGV0YWlscyIsInNpZ25hdHVyZSIsInR4IiwiZW5jb2RpbmciLCJtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb24iLCJ0b2tlblRyYW5zZmVyIiwibWV0YSIsInBvc3RUb2tlbkJhbGFuY2VzIiwibGVuZ3RoIiwicHJlVG9rZW5CYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZUJhbGFuY2VzIiwiaSIsIk1hdGgiLCJtYXgiLCJwb3N0QmFsYW5jZSIsInByZUJhbGFuY2UiLCJmaW5kIiwicHJlIiwiYWNjb3VudEluZGV4IiwidWlUb2tlbkFtb3VudCIsImFtb3VudCIsImFicyIsInVpQW1vdW50IiwidG9rZW5BZGRyZXNzIiwidHJhbnNhY3Rpb24iLCJhY2NvdW50S2V5cyIsInN5bWJvbCIsInVpVG9rZW5TeW1ib2wiLCJ0eXBlIiwidGltZXN0YW1wIiwiYmxvY2tUaW1lIiwidG9Mb2NhbGVTdHJpbmciLCJlcnIiLCJmZWUiLCJ1bmRlZmluZWQiLCJzZW5kZXIiLCJyZWNlaXZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/helius.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/wallet.ts":
/*!*****************************!*\
  !*** ./src/utils/wallet.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentWallet: function() { return /* binding */ AgentWallet; },\n/* harmony export */   agentWallet: function() { return /* binding */ agentWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../../node_modules/process/browser.js\");\n\nclass AgentWallet {\n    async getActiveConnection() {\n        if (!this.isUsingFallback) {\n            try {\n                if (!this.primaryConnection) {\n                    throw new Error(\"Primary connection not initialized\");\n                }\n                await this.primaryConnection.getSlot();\n                return this.primaryConnection;\n            } catch (error) {\n                console.warn(\"Primary RPC failed, switching to fallback:\", error);\n                this.isUsingFallback = true;\n            }\n        }\n        if (!this.fallbackConnection) {\n            throw new Error(\"Fallback connection not initialized\");\n        }\n        try {\n            await this.fallbackConnection.getSlot();\n            return this.fallbackConnection;\n        } catch (error) {\n            console.error(\"Both RPC connections failed:\", error);\n            throw new Error(\"No available RPC connection\");\n        }\n    }\n    async getBalance() {\n        const maxRetries = 3;\n        let retryCount = 0;\n        while(retryCount < maxRetries){\n            try {\n                const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet\"), {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Failed to get wallet balance\");\n                }\n                return await response.json();\n            } catch (error) {\n                retryCount++;\n                if (retryCount === maxRetries) {\n                    console.error(\"Error getting wallet balance after retries:\", error);\n                    throw error;\n                }\n                // Wait before retrying\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            }\n        }\n        throw new Error(\"Failed to get wallet balance after retries\");\n    }\n    async sendSOL(recipient, amount) {\n        try {\n            const connection = await this.getActiveConnection();\n            const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet/send\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    recipient,\n                    amount,\n                    rpcUrl: this.isUsingFallback ? \"helius\" : \"quicknode\"\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to send transaction\");\n            }\n            return response.json();\n        } catch (error) {\n            console.error(\"Error sending SOL:\", error);\n            throw error;\n        }\n    }\n    async signAndSendTransaction(transaction) {\n        try {\n            const connection = await this.getActiveConnection();\n            const serializedTransaction = Buffer.from(transaction.serialize()).toString(\"base64\");\n            const response = await fetch(\"\".concat(this.baseUrl, \"/api/wallet/sign\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    transaction: serializedTransaction,\n                    rpcUrl: this.isUsingFallback ? \"helius\" : \"quicknode\"\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to sign and send transaction\");\n            }\n            const result = await response.json();\n            return result.signature;\n        } catch (error) {\n            console.error(\"Error signing transaction:\", error);\n            throw error;\n        }\n    }\n    async getAddress() {\n        const walletInfo = await this.getBalance();\n        return walletInfo.address;\n    }\n    constructor(){\n        this.primaryConnection = null;\n        this.fallbackConnection = null;\n        this.isUsingFallback = false;\n        const quickNodeUrl = process.env.NEXT_PUBLIC_QUICKNODE_RPC_URL;\n        const heliusApiKey = process.env.NEXT_PUBLIC_HELIUS_API_KEY;\n        if (!quickNodeUrl && !heliusApiKey) {\n            throw new Error(\"Missing RPC configuration\");\n        }\n        // Initialize QuickNode as primary if available\n        if (quickNodeUrl) {\n            this.primaryConnection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(quickNodeUrl, \"confirmed\");\n        }\n        // Initialize Helius as fallback\n        if (heliusApiKey) {\n            this.fallbackConnection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(\"https://mainnet.helius-rpc.com/?api-key=\".concat(heliusApiKey), \"confirmed\");\n        }\n        // If QuickNode isn't available, use Helius as primary\n        if (!quickNodeUrl && heliusApiKey) {\n            this.primaryConnection = this.fallbackConnection;\n        }\n        // Use appropriate base URL depending on environment\n        this.baseUrl = process.env.BOT_API_BASE_URL || process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:3000\";\n    }\n}\n// Export a singleton instance\nconst agentWallet = new AgentWallet();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ3RELElBQUksQ0FBQ0osZ0JBQWdCSSxjQUFjO1lBQ2pDLElBQUksQ0FBQzlDLGlCQUFpQixHQUFHLElBQUksQ0FBQ00sa0JBQWtCO1FBQ2xEO1FBRUEsb0RBQW9EO1FBQ3BELElBQUksQ0FBQ00sT0FBTyxHQUFHK0IsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSSxnQkFBZ0IsSUFBSUwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSyx3QkFBd0IsSUFBSTtJQUN6RjtBQW9IRjtBQUVBLDhCQUE4QjtBQUN2QixNQUFNQyxjQUFjLElBQUlyRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy93YWxsZXQudHM/MjkwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5cbmludGVyZmFjZSBXYWxsZXRCYWxhbmNlIHtcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBhZGRyZXNzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblJlc3VsdCB7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xuICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdlcnJvcic7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFnZW50V2FsbGV0IHtcbiAgcHJpdmF0ZSBwcmltYXJ5Q29ubmVjdGlvbjogQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGZhbGxiYWNrQ29ubmVjdGlvbjogQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzVXNpbmdGYWxsYmFjazogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBxdWlja05vZGVVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19RVUlDS05PREVfUlBDX1VSTDtcbiAgICBjb25zdCBoZWxpdXNBcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUxJVVNfQVBJX0tFWTtcblxuICAgIGlmICghcXVpY2tOb2RlVXJsICYmICFoZWxpdXNBcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBSUEMgY29uZmlndXJhdGlvbicpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgUXVpY2tOb2RlIGFzIHByaW1hcnkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHF1aWNrTm9kZVVybCkge1xuICAgICAgdGhpcy5wcmltYXJ5Q29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHF1aWNrTm9kZVVybCwgJ2NvbmZpcm1lZCcpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgSGVsaXVzIGFzIGZhbGxiYWNrXG4gICAgaWYgKGhlbGl1c0FwaUtleSkge1xuICAgICAgdGhpcy5mYWxsYmFja0Nvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcbiAgICAgICAgYGh0dHBzOi8vbWFpbm5ldC5oZWxpdXMtcnBjLmNvbS8/YXBpLWtleT0ke2hlbGl1c0FwaUtleX1gLFxuICAgICAgICAnY29uZmlybWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJZiBRdWlja05vZGUgaXNuJ3QgYXZhaWxhYmxlLCB1c2UgSGVsaXVzIGFzIHByaW1hcnlcbiAgICBpZiAoIXF1aWNrTm9kZVVybCAmJiBoZWxpdXNBcGlLZXkpIHtcbiAgICAgIHRoaXMucHJpbWFyeUNvbm5lY3Rpb24gPSB0aGlzLmZhbGxiYWNrQ29ubmVjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBVc2UgYXBwcm9wcmlhdGUgYmFzZSBVUkwgZGVwZW5kaW5nIG9uIGVudmlyb25tZW50XG4gICAgdGhpcy5iYXNlVXJsID0gcHJvY2Vzcy5lbnYuQk9UX0FQSV9CQVNFX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWN0aXZlQ29ubmVjdGlvbigpOiBQcm9taXNlPENvbm5lY3Rpb24+IHtcbiAgICBpZiAoIXRoaXMuaXNVc2luZ0ZhbGxiYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMucHJpbWFyeUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1hcnkgY29ubmVjdGlvbiBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnByaW1hcnlDb25uZWN0aW9uLmdldFNsb3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeUNvbm5lY3Rpb247XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1ByaW1hcnkgUlBDIGZhaWxlZCwgc3dpdGNoaW5nIHRvIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhpcy5pc1VzaW5nRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5mYWxsYmFja0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsbGJhY2sgY29ubmVjdGlvbiBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZmFsbGJhY2tDb25uZWN0aW9uLmdldFNsb3QoKTtcbiAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrQ29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQm90aCBSUEMgY29ubmVjdGlvbnMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIFJQQyBjb25uZWN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0QmFsYW5jZSgpOiBQcm9taXNlPHsgYWRkcmVzczogc3RyaW5nOyBiYWxhbmNlOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICBcbiAgICB3aGlsZSAocmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9hcGkvd2FsbGV0YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHdhbGxldCBiYWxhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICBpZiAocmV0cnlDb3VudCA9PT0gbWF4UmV0cmllcykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgd2FsbGV0IGJhbGFuY2UgYWZ0ZXIgcmV0cmllczonLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHdhbGxldCBiYWxhbmNlIGFmdGVyIHJldHJpZXMnKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRTT0wocmVjaXBpZW50OiBzdHJpbmcsIGFtb3VudDogbnVtYmVyKTogUHJvbWlzZTxUcmFuc2FjdGlvblJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5nZXRBY3RpdmVDb25uZWN0aW9uKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vYXBpL3dhbGxldC9zZW5kYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgcmVjaXBpZW50LCBcbiAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgcnBjVXJsOiB0aGlzLmlzVXNpbmdGYWxsYmFjayA/ICdoZWxpdXMnIDogJ3F1aWNrbm9kZScgXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2VuZCB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIFNPTDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBWZXJzaW9uZWRUcmFuc2FjdGlvbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmdldEFjdGl2ZUNvbm5lY3Rpb24oKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9hcGkvd2FsbGV0L3NpZ25gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgICB0cmFuc2FjdGlvbjogc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgICAgIHJwY1VybDogdGhpcy5pc1VzaW5nRmFsbGJhY2sgPyAnaGVsaXVzJyA6ICdxdWlja25vZGUnIFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIHNpZ24gYW5kIHNlbmQgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zaWduYXR1cmU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNpZ25pbmcgdHJhbnNhY3Rpb246JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEFkZHJlc3MoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKCk7XG4gICAgcmV0dXJuIHdhbGxldEluZm8uYWRkcmVzcztcbiAgfVxufVxuXG4vLyBFeHBvcnQgYSBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBhZ2VudFdhbGxldCA9IG5ldyBBZ2VudFdhbGxldCgpO1xuIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJBZ2VudFdhbGxldCIsImdldEFjdGl2ZUNvbm5lY3Rpb24iLCJpc1VzaW5nRmFsbGJhY2siLCJwcmltYXJ5Q29ubmVjdGlvbiIsIkVycm9yIiwiZ2V0U2xvdCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJmYWxsYmFja0Nvbm5lY3Rpb24iLCJnZXRCYWxhbmNlIiwibWF4UmV0cmllcyIsInJldHJ5Q291bnQiLCJyZXNwb25zZSIsImZldGNoIiwiYmFzZVVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsImpzb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzZW5kU09MIiwicmVjaXBpZW50IiwiYW1vdW50IiwiY29ubmVjdGlvbiIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicnBjVXJsIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwiQnVmZmVyIiwiZnJvbSIsInNlcmlhbGl6ZSIsInRvU3RyaW5nIiwiZXJyb3JEYXRhIiwicmVzdWx0Iiwic2lnbmF0dXJlIiwiZ2V0QWRkcmVzcyIsIndhbGxldEluZm8iLCJhZGRyZXNzIiwiY29uc3RydWN0b3IiLCJxdWlja05vZGVVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfUVVJQ0tOT0RFX1JQQ19VUkwiLCJoZWxpdXNBcGlLZXkiLCJORVhUX1BVQkxJQ19IRUxJVVNfQVBJX0tFWSIsIkJPVF9BUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJhZ2VudFdhbGxldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/wallet.ts\n"));

/***/ })

});